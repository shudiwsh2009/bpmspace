/** * BeehiveZ is a business process model and instance management system. * Copyright (C) 2011   * Institute of Information System and Engineering, School of Software, Tsinghua University, * Beijing, China * * Contact: jintao05@gmail.com  * * This program is a free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License * as published by the Free Software Foundation with the version of 2. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. *//*please use UTF-8 * This is a JJTree file that is used to generate query expression parser.* Expression ::= AndExpression {"or" AndExpression}* AndExpression ::= UnaryExpression {"and" UnaryExpression}* UnaryExpression :: = "(" Expression ")" | Activity [Op Activity]* Activity ::= """" (~[""""])+ """""* OP ::= ∥|>|»|→|↠|⊚|×*/options{  JAVA_UNICODE_ESCAPE = true;  UNICODE_INPUT = false;  STATIC = false;  MULTI=true;  KEEP_LINE_COLUMN = false;}PARSER_BEGIN(Parser)package cn.edu.thss.iise.beehivez.server.index.petrinetindex.rltMatrix.queryParser;import java.io.StringReader;/** An Arithmetic Grammar. */public class Parser {  /** Main entry point. */  public static void main(String args[])  {    System.out.println("Reading from standard input...");    Parser t = new Parser(new StringReader("\"activity1\" and \"activity2\" or \"activyty3\" and \"activiyt4\""));    try {      ASTStart n = t.Start();      n.dump("");      System.out.println("Thank you.");    } catch (Exception e) {      System.out.println("Oops.");      System.out.println(e.getMessage());      e.printStackTrace();    }  }}PARSER_END(Parser)SKIP :{  " "| "\t"| "\n"| "\r"}TOKEN:{	<OP : <RLT_PARALLEL> | <RLT_DIR_SUCC> | <RLT_INDIR_SUCC> | <RLT_DIR_CASUAL>	    | <RLT_INDIR_CASUAL> | <RLT_CYCLE> | <RLT_MUTEX>	> | <#RLT_PARALLEL : "\u2225">| <#RLT_DIR_SUCC : ">">| <#RLT_INDIR_SUCC : "\u00BB">| <#RLT_DIR_CASUAL : "\u2192">| <#RLT_INDIR_CASUAL : "\u21A0">| <#RLT_CYCLE : "\u229A">| <#RLT_MUTEX : "\u00D7">| <AND : "and" >| <OR : "or" >| <ACTIVITY : "\"" (~["\""])+ "\"" >}/** Main production. */ASTStart Start() : {}{  Expression() ";"  { return jjtThis; }}/** An Expression. */void Expression() #void : {}{  OrExpression()}/** An Or Expression. */void OrExpression() #void : {}{  (    AndExpression() ( ( "or" ) AndExpression() )*  ) #Or(>1)}/** A And Expression. */void AndExpression() #void : {}{  (    UnaryExpression() ( ( "and" ) UnaryExpression() )*  ) #And(>1)}/** A Unary Expression. */void UnaryExpression() #void :{  Token t;}{  "(" Expression() ")"  | (Activity() [t = <OP>  {    jjtThis.setValue(t.image);  } Activity()]) #Op(>1) }/** An Activity. */void Activity() :{  Token t;}{  t=<ACTIVITY>  {    jjtThis.setValue(t.image);  }}