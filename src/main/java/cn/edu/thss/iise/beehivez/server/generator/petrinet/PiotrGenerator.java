/**
 * BeehiveZ is a business process model and instance management system.
 * Copyright (C) 2011  
 * Institute of Information System and Engineering, School of Software, Tsinghua University,
 * Beijing, China
 *
 * Contact: jintao05@gmail.com 
 *
 * This program is a free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation with the version of 2.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

/**
 * Use the rules presented in the paper "A Top-Down Petri Net-Based Approach for Dynamic Workflow Modeling", 
 * which was published in BPM 2003.
 * 
 * There are five basic refinement rules and three rules for adding 
 * communication and synchronization mechanisms.
 * 
 * five basic refinement rules:
 * (1)sequential place split
 * (2)sequential transition split
 * (3)or-split
 * (4)and-split
 * (5)loop
 * 
 * three non-refinement rules:
 * (6)communication rule
 * (7)symmetric synchronization
 * (8)asymmetric synchronization
 * 
 * when some node is chosen to be splited, the original node always stays as the latter part of the split
 */
package cn.edu.thss.iise.beehivez.server.generator.petrinet;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Vector;

import org.processmining.framework.log.LogEvent;
import org.processmining.framework.models.petrinet.PNNode;
import org.processmining.framework.models.petrinet.PetriNet;
import org.processmining.framework.models.petrinet.Place;
import org.processmining.framework.models.petrinet.Transition;

import cn.edu.thss.iise.beehivez.server.util.PetriNetUtil;

/**
 * @author Tao Jin
 * 
 */
public class PiotrGenerator extends PetriNetGenerator {

	private static final boolean debug = false;

	private int MaxTransitionNameLength = 0;

	public PetriNet generateModel(int minTransitionsPerNet,
			int maxTransitionsPerNet, int maxDegree, int maxTransitionNameLength) {
		if (minTransitionsPerNet > maxTransitionsPerNet
				|| minTransitionsPerNet < 1 || maxTransitionsPerNet < 1
				|| maxTransitionNameLength < 1) {
			System.out.println("invalid parameters in PiotrGenerator.generate");
			return null;
		}
		MaxTransitionNameLength = maxTransitionNameLength;

		// record the result Petri net
		PetriNet pn = new PetriNet();
		pn.setIdentifier(String.valueOf(System.currentTimeMillis()));

		// record the number of transition in the result petri net
		int nTransitions = 0;

		// used for unused place
		// andSplit maybe generate some unused places.
		// if the places generated by andSplit rule are not used for another
		// rules,
		// it must be unused places.
		// Or if some place is used for another rules, it must be deleted from
		// this vector.
		// At last, all the places in this vector must be deleted from the Petri
		// net.
		Vector<Place> maybeUnusedPlaces = new Vector<Place>();

		// generate the initial Petri net
		// there are two places and one transition
		// the source place is labeled with "pSource"
		// the sink place is labeled with "pSink"
		// all the other places are labeled with "p" followed by a number
		// the transitions' label is generated randomly
		Place pSource = new Place("pSource", pn);
		pn.addPlace(pSource);
		Place pSink = new Place("pSink", pn);
		pn.addPlace(pSink);
		String tName = getRandomString(MaxTransitionNameLength);
		Transition t = new Transition(tName, pn);
		LogEvent le = new LogEvent(tName, "auto");
		t.setLogEvent(le);
		pn.addTransition(t);
		nTransitions++;
		pn.addEdge(pSource, t);
		pn.addEdge(t, pSink);

		// record the history of refinement in the refinement tree
		RefinementTree rfTree = new RefinementTree(pSource, t, pSink);

		int transitionNumber = rand.nextInt(maxTransitionsPerNet
				- minTransitionsPerNet + 1)
				+ minTransitionsPerNet;

		// generate the result petri net step by step
		while (nTransitions < transitionNumber) {
			// first choose the rule, and then choose the nodes involved.
			int choice = rand.nextInt(8);
			if (debug) {
				System.out.println(nTransitions + "," + choice + ";");
			}
			switch (choice) {
			case 0:
				nTransitions = sequentialPlaceSplit(pn, maybeUnusedPlaces,
						rfTree);
				break;
			case 1:
				nTransitions = sequentialTransitionSplit(pn, maybeUnusedPlaces,
						rfTree);
				break;
			case 2:
				nTransitions = orSplit(pn, maybeUnusedPlaces, rfTree);
				// nTransitions = andSplit(pn, maybeUnusedPlaces, rfTree);
				break;
			case 3:
				nTransitions = andSplit(pn, maybeUnusedPlaces, rfTree);
				break;
			case 4:
				nTransitions = loopSplit(pn, maybeUnusedPlaces, rfTree);
				// nTransitions = andSplit(pn, maybeUnusedPlaces, rfTree);
				break;
			case 5:
				nTransitions = addCommunication(pn, maybeUnusedPlaces, rfTree);
				// nTransitions = addAsymmetricSynchronization(pn,
				// maybeUnusedPlaces, rfTree);
				// nTransitions = addSymmetricSynchronization(pn,
				// maybeUnusedPlaces, rfTree);
				break;
			case 6:
				// nTransitions = addCommunication(pn, maybeUnusedPlaces,
				// rfTree);
				nTransitions = addAsymmetricSynchronization(pn,
						maybeUnusedPlaces, rfTree);
				// nTransitions = addSymmetricSynchronization(pn,
				// maybeUnusedPlaces, rfTree);
				break;
			case 7:
				// nTransitions = addCommunication(pn, maybeUnusedPlaces,
				// rfTree);
				// nTransitions = addAsymmetricSynchronization(pn,
				// maybeUnusedPlaces, rfTree);
				nTransitions = addSymmetricSynchronization(pn,
						maybeUnusedPlaces, rfTree);
				break;
			}
		}

		// delete unused places
		for (Place p : maybeUnusedPlaces) {
			boolean canDeleted = true;

			Iterator it = p.getPredecessors().iterator();
			while (it.hasNext()) {
				Transition tPre = (Transition) it.next();
				if (tPre.outDegree() == 1) {
					canDeleted = false;
					break;
				}
			}

			if (canDeleted) {
				it = p.getSuccessors().iterator();
				while (it.hasNext()) {
					Transition tSuc = (Transition) it.next();
					if (tSuc.inDegree() == 1) {
						canDeleted = false;
						break;
					}
				}
			}

			if (canDeleted) {
				pn.delPlace(p);
			}
		}

		return pn;
	}

	private int sequentialPlaceSplit(PetriNet pn,
			Vector<Place> maybeUnusedPlaces, RefinementTree rfTree) {

		// choose one place randomly
		ArrayList<Place> places = pn.getPlaces();
		Place pChosen = places.get(rand.nextInt(places.size()));

		// split the chosen place
		// the original place stays as the later part
		// the source place and sinke place cannot be split
		// if (!pChosen.getIdentifier().equals("pSource")
		// && !pChosen.getIdentifier().equals("pSink")) {
		if (pChosen.inDegree() > 0 && pChosen.outDegree() > 0) {
			Place pNew = new Place("p" + places.size(), pn);
			pn.addPlace(pNew);

			Iterator it = pChosen.getPredecessors().iterator();
			while (it.hasNext()) {
				Transition tPre = (Transition) it.next();
				pn.delEdge(tPre, pChosen);
				pn.addEdge(tPre, pNew);
			}

			String tName = getRandomString(MaxTransitionNameLength);
			Transition tNew = new Transition(tName, pn);
			LogEvent le = new LogEvent(tName, "auto");
			tNew.setLogEvent(le);
			pn.addTransition(tNew);

			pn.addEdge(pNew, tNew);
			pn.addEdge(tNew, pChosen);

			// remove the place from the maybeUnusedPlaces if necessary
			maybeUnusedPlaces.remove(pChosen);

			// record the split info into the refinement tree
			Vector<PNNode> newPNNodes = new Vector<PNNode>();
			newPNNodes.add(tNew);
			newPNNodes.add(pNew);
			rfTree.recordRefinement(pChosen, RefinementTree.sequentialSplit,
					newPNNodes);
		}

		return pn.getTransitions().size();
	}

	private int sequentialTransitionSplit(PetriNet pn,
			Vector<Place> maybeUnusedPlaces, RefinementTree rfTree) {

		// first choose one transition
		ArrayList<Transition> transitions = pn.getTransitions();
		Transition tChosen = transitions.get(rand.nextInt(transitions.size()));

		// split the chosen transition
		// the origin transition stay as the later part
		String tName = getRandomString(MaxTransitionNameLength);
		Transition tNew = new Transition(tName, pn);
		LogEvent le = new LogEvent(tName, "auto");
		tNew.setLogEvent(le);
		pn.addTransition(tNew);

		Iterator it = tChosen.getPredecessors().iterator();
		while (it.hasNext()) {
			Place pPre = (Place) it.next();
			pn.delEdge(pPre, tChosen);
			pn.addEdge(pPre, tNew);
		}

		Place pNew = new Place("p" + pn.getPlaces().size(), pn);
		pn.addPlace(pNew);

		pn.addEdge(tNew, pNew);
		pn.addEdge(pNew, tChosen);

		// record information into the refinement tree
		Vector<PNNode> newPNNodes = new Vector<PNNode>();
		newPNNodes.add(pNew);
		newPNNodes.add(tNew);
		rfTree.recordRefinement(tChosen, RefinementTree.sequentialSplit,
				newPNNodes);

		return pn.getTransitions().size();
	}

	private int orSplit(PetriNet pn, Vector<Place> maybeUnusedPlaces,
			RefinementTree rfTree) {
		// chose one transition
		ArrayList<Transition> transitions = pn.getTransitions();
		Transition tChosen = transitions.get(rand.nextInt(transitions.size()));

		// add a new transition
		// and copy all the links to the new transition
		String tName = getRandomString(MaxTransitionNameLength);
		Transition tNew = new Transition(tName, pn);
		LogEvent le = new LogEvent(tName, "auto");
		tNew.setLogEvent(le);
		pn.addTransition(tNew);

		Iterator it = tChosen.getPredecessors().iterator();
		while (it.hasNext()) {
			Place pPre = (Place) it.next();
			pn.addEdge(pPre, tNew);
			maybeUnusedPlaces.remove(pPre);
		}

		it = tChosen.getSuccessors().iterator();
		while (it.hasNext()) {
			Place pSuc = (Place) it.next();
			pn.addEdge(tNew, pSuc);
			maybeUnusedPlaces.remove(pSuc);
		}

		// record the information into the refinement tree
		Vector<PNNode> newPNNodes = new Vector<PNNode>();
		newPNNodes.add(tNew);
		rfTree.recordRefinement(tChosen, RefinementTree.orSplit, newPNNodes);

		return pn.getTransitions().size();
	}

	private int andSplit(PetriNet pn, Vector<Place> maybeUnusedPlaces,
			RefinementTree rfTree) {

		// choose a place to split
		// the place cannot be the source and sink place
		ArrayList<Place> places = pn.getPlaces();
		Place pChosen = places.get(rand.nextInt(places.size()));
		// if (!pChosen.getIdentifier().equals("pSource")
		// && !pChosen.getIdentifier().equals("pSink")) {
		if (pChosen.inDegree() > 0 && pChosen.outDegree() > 0) {

			// add a new place
			// and copy all the links to the new place
			Place pNew = new Place("p" + places.size(), pn);
			pn.addPlace(pNew);

			Iterator it = pChosen.getPredecessors().iterator();
			while (it.hasNext()) {
				Transition tPre = (Transition) it.next();
				pn.addEdge(tPre, pNew);
			}

			it = pChosen.getSuccessors().iterator();
			while (it.hasNext()) {
				Transition tSuc = (Transition) it.next();
				pn.addEdge(pNew, tSuc);
			}

			// record the new place in maybeUnusedPlaces
			maybeUnusedPlaces.add(pNew);
			// maybeUnusedPlaces.add(pChosen);

			// record the information into the refinement tree
			Vector<PNNode> newPNNodes = new Vector<PNNode>();
			newPNNodes.add(pNew);
			rfTree.recordRefinement(pChosen, RefinementTree.andSplit,
					newPNNodes);
		}

		return pn.getTransitions().size();
	}

	private int loopSplit(PetriNet pn, Vector<Place> maybeUnusedPlaces,
			RefinementTree rfTree) {
		// choose one place to split
		// the place cannot be the source or the sink place
		ArrayList<Place> places = pn.getPlaces();
		Place pChosen = places.get(rand.nextInt(places.size()));

		// if (!pChosen.getIdentifier().equals("pSource")
		// && !pChosen.getIdentifier().equals("pSink")) {
		if (pChosen.inDegree() > 0 && pChosen.outDegree() > 0) {
			// add new transition
			String tName = getRandomString(MaxTransitionNameLength);
			Transition tNew = new Transition(tName, pn);
			LogEvent le = new LogEvent(tName, "auto");
			tNew.setLogEvent(le);
			pn.addTransition(tNew);

			pn.addEdge(pChosen, tNew);
			pn.addEdge(tNew, pChosen);

			// remove the place from the maybeUnusedPlaces if possible
			maybeUnusedPlaces.remove(pChosen);

			// record the information into the refinement tree
			Vector<PNNode> newPNNodes = new Vector<PNNode>();
			newPNNodes.add(tNew);
			rfTree.recordRefinement(pChosen, RefinementTree.loopSplit,
					newPNNodes);
		}

		return pn.getTransitions().size();
	}

	private int addCommunication(PetriNet pn, Vector<Place> maybeUnusedPlaces,
			RefinementTree rfTree) {
		// //////////////////////////////////////////
		// choose two transitions randomly
		// /////////////////////////////////////////////
		ArrayList<Transition> transitions = pn.getTransitions();
		Transition startTransition = transitions.get(rand.nextInt(transitions
				.size()));
		Transition endTransition = transitions.get(rand.nextInt(transitions
				.size()));

		if (PetriNetUtil.existCommunication(startTransition, endTransition)) {
			return pn.getTransitions().size();
		}

		// check if the transitions chosen are on parallel threads
		if (!rfTree.isCompleteParallel(startTransition, endTransition)) {
			// System.out.println("not on the parallel threads");
			return pn.getTransitions().size();
		}

		// ///////////////////////////////
		// check if there would be a loop
		// ///////////////////////////////
		if (PetriNetUtil.canReach(endTransition, startTransition)) {
			// System.out.println("would be loop");
			return pn.getTransitions().size();
		}

		if (debug) {
			System.out.println("add new nodes...");
		}

		// ////////////////////////////////////////////
		// add communication between chosen transitions
		// /////////////////////////////////////////////
		Place newPlace = new Place("p" + pn.getPlaces().size(), pn);
		pn.addPlace(newPlace);
		pn.addEdge(startTransition, newPlace);
		pn.addEdge(newPlace, endTransition);

		// System.out.println("==============================");
		// System.out.println("add communication successfully for: "
		// + pn.getIdentifier());
		// System.out.println("start transition is: "
		// + startTransition.getIdentifier());
		// System.out.println("end transition is: "
		// + endTransition.getIdentifier());
		// System.out.println("communication place is: "
		// + newPlace.getIdentifier());

		return pn.getTransitions().size();
	}

	private int addSymmetricSynchronization(PetriNet pn,
			Vector<Place> maybeUnusedPlaces, RefinementTree rfTree) {

		// ///////////////////////////////////
		// choose two places randomly
		// /////////////////////////////
		ArrayList<Place> places = pn.getPlaces();
		Place startPlace = places.get(rand.nextInt(places.size()));
		Place endPlace = places.get(rand.nextInt(places.size()));

		if (maybeUnusedPlaces.indexOf(startPlace) >= 0
				|| maybeUnusedPlaces.indexOf(endPlace) >= 0) {
			return pn.getTransitions().size();
		}

		if (PetriNetUtil.existSynchronization(startPlace, endPlace)) {
			return pn.getTransitions().size();
		}

		// check if the two places are on parallel threads
		if (!rfTree.isCompleteParallel(startPlace, endPlace)) {
			return pn.getTransitions().size();
		}

		// check if there would be a loop
		if (PetriNetUtil.canReach(startPlace, endPlace)
				|| PetriNetUtil.canReach(endPlace, startPlace)) {
			return pn.getTransitions().size();
		}

		if (debug) {
			System.out.println("add new nodes...");
		}

		// add synchronization
		// add two places and one synchronization transition
		Place fStartPlace = new Place("p" + places.size(), pn);
		pn.addPlace(fStartPlace);
		Iterator it = startPlace.getPredecessors().iterator();
		while (it.hasNext()) {
			Transition tPre = (Transition) it.next();
			pn.delEdge(tPre, startPlace);
			pn.addEdge(tPre, fStartPlace);
		}

		Place fEndPlace = new Place("p" + places.size(), pn);
		pn.addPlace(fEndPlace);
		it = endPlace.getPredecessors().iterator();
		while (it.hasNext()) {
			Transition tPre = (Transition) it.next();
			pn.delEdge(tPre, endPlace);
			pn.addEdge(tPre, fEndPlace);
		}

		String tName = getRandomString(MaxTransitionNameLength);
		Transition tNew = new Transition(tName, pn);
		LogEvent le = new LogEvent(tName, "auto");
		tNew.setLogEvent(le);
		pn.addTransition(tNew);

		pn.addEdge(fStartPlace, tNew);
		pn.addEdge(fEndPlace, tNew);
		pn.addEdge(tNew, startPlace);
		pn.addEdge(tNew, endPlace);

		// System.out.println("============================");
		// System.out.println("add symmetric synchronization successfully for: "
		// + pn.getIdentifier());
		// System.out.println("start place is: " + startPlace.getIdentifier());
		// System.out.println("the copy of start place is: "
		// + fStartPlace.getIdentifier());
		// System.out.println("end place is: " + endPlace.getIdentifier());
		// System.out.println("the copy of end place is: "
		// + fEndPlace.getIdentifier());
		// System.out.println("the synchronization transition is: "
		// + tNew.getIdentifier());

		// remove the places chosen from the maybeUnusedPlaces
		maybeUnusedPlaces.remove(startPlace);
		maybeUnusedPlaces.remove(endPlace);

		return pn.getTransitions().size();
	}

	private int addAsymmetricSynchronization(PetriNet pn,
			Vector<Place> maybeUnusedPlaces, RefinementTree rfTree) {

		// ///////////////////////////////////
		// choose two places randomly
		// /////////////////////////////
		ArrayList<Place> places = pn.getPlaces();
		Place startPlace = places.get(rand.nextInt(places.size()));
		Place endPlace = places.get(rand.nextInt(places.size()));

		if (maybeUnusedPlaces.indexOf(startPlace) >= 0
				|| maybeUnusedPlaces.indexOf(endPlace) >= 0) {
			return pn.getTransitions().size();
		}

		if (PetriNetUtil.existSynchronization(startPlace, endPlace)) {
			return pn.getTransitions().size();
		}

		// check if the two places are on parallel threads
		if (!rfTree.isCompleteParallel(startPlace, endPlace)) {
			return pn.getTransitions().size();
		}

		// check if there would be a loop
		if (PetriNetUtil.canReach(endPlace, startPlace)) {
			return pn.getTransitions().size();
		}

		if (debug) {
			System.out.println("add new nodes...");
		}

		// add synchronization
		// add two places and one synchronization transition
		Place fStartPlace = new Place("p" + places.size(), pn);
		pn.addPlace(fStartPlace);
		Iterator it = startPlace.getPredecessors().iterator();
		while (it.hasNext()) {
			Transition tPre = (Transition) it.next();
			pn.delEdge(tPre, startPlace);
			pn.addEdge(tPre, fStartPlace);
		}

		Place fEndPlace = new Place("p" + places.size(), pn);
		pn.addPlace(fEndPlace);
		it = endPlace.getSuccessors().iterator();
		while (it.hasNext()) {
			Transition tSuc = (Transition) it.next();
			pn.addEdge(fEndPlace, tSuc);
		}

		String tName = getRandomString(MaxTransitionNameLength);
		Transition tNew = new Transition(tName, pn);
		LogEvent le = new LogEvent(tName, "auto");
		tNew.setLogEvent(le);
		pn.addTransition(tNew);

		pn.addEdge(fStartPlace, tNew);
		pn.addEdge(tNew, startPlace);
		pn.addEdge(tNew, fEndPlace);

		// System.out.println("==================================");
		// System.out.println("add asymmetric synchronization successfully for: "
		// + pn.getIdentifier());
		// System.out.println("start place is: " + startPlace.getIdentifier());
		// System.out.println("the copy of start place is: "
		// + fStartPlace.getIdentifier());
		// System.out.println("end place is: " + endPlace.getIdentifier());
		// System.out.println("the copy of end place is: "
		// + fEndPlace.getIdentifier());
		// System.out.println("the synchronization transition is: "
		// + tNew.getIdentifier());

		// remove the places chosen from the maybeUnusedPlaces
		maybeUnusedPlaces.remove(startPlace);
		maybeUnusedPlaces.remove(endPlace);

		return pn.getTransitions().size();
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		for (int i = 0; i < 1000; i++) {
			System.out.println(i);
			PiotrGenerator generator = new PiotrGenerator();
			generator.generateModel(600, 600, -1, 3);
		}
	}

	@Override
	public boolean supportDegreeConfiguration() {
		return false;
	}

}
